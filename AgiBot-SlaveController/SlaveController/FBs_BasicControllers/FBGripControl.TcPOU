<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FBGripControl" Id="{133d07e3-99c5-4338-ad65-0a5f3241047e}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: Control gripper finger in current mode. All the variables are defined in instrument coordinate
// Author: Feijian Ni
// Date: 2023.11.16
FUNCTION_BLOCK FBGripControl
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//TODO: move to GVLs 
	// instrument PID control paramters
	m_instruKp:ARRAY[1..4] OF LREAL:=[35,35,35,35];
	m_instruKd:ARRAY[1..4] OF LREAL:=[2.0,2.0,2.0,2.0];
	m_instruKi:ARRAY[1..4] OF LREAL:=[100,100,100,100];
	m_instruKiLimit:ARRAY[1..4] OF LREAL:=[4(50.0)];
	m_instruCtrlLimit:ARRAY[1..4] OF LREAL:=[4(200.0)];
	
	// yaw PID control (when fingers grasp with force)
	m_yawKp:LREAL:=50;
	m_yawKd:LREAL:=3.0;
	m_yawKi:LREAL:=100;
	m_yawKiLimit:LREAL:=100.0;
	m_yawCtrlLimit:LREAL:=200.0;
	
	// max grip force/current(mA)
	m_maxGripForce:LREAL:=180.0;
	
	// max command rotation velocity
	m_instruMaxWVel:LREAL:=3*pi;
	
	// max feed forward grasp force
	m_maxGraspFroce:LREAL;
	
	// max finger control torque
	m_maxCtrlTrq:LREAL;
	
	// arm index for grip control
	m_armIdx:INT;
	
	// data struct for current instrument joint position
	m_instruCurJointData:ST_effector_position_Joint;
	
	// final target instrument orientation 
	m_instruTargetCartOri:ST_effector_position_Cartesian;
	
	// next command instrument orientation 
	m_instruCmdCartOri:ST_effector_position_Cartesian;
	
	// command instrument cartesian velocity(wx,wy,wz, openAngle)
	m_instruCmdWVel:ARRAY[1..4] OF LREAL;
	
	// current instrument orientation 
	m_instruCurCartOri:ST_effector_position_Cartesian;
	
	// function for instrument forward kinematic
	m_instruFK:power_box_forward_kinematics;
	
	// function for instrument inverse kinematic
	m_instruIK:power_box_inverse_kinematics;
	
	// grasp force level
	m_graspForceLevel:UINT :=0;
	
	// PID for instrument joint position
	m_instruJntCtrl:ARRAY[1..4] OF FBPID;
	
	// PID for instrument yaw angle 
	m_instruYawCtrl : FBPID;
	
	// current gripper yaw velocity
	m_instruCurYawVel:LREAL;
	
	// yaw angle error(deg)
	m_yawAngErr : LREAL;
	
	// command instrument joint position and velocity
	m_instruCmdJntPos:ARRAY[1..4] OF LREAL:=[4(0.0)];
	m_instruLastCmdJntPos:ARRAY[1..4] OF LREAL:=[4(0.0)];
	m_instruCmdJntVel:ARRAY[1..4] OF LREAL:=[4(0.0)];
	
	// command instrument joint position and velocity
	m_instruCurJntPos:ARRAY[1..4] OF LREAL:=[4(0.0)];
	m_instruCurJntVel:ARRAY[1..4] OF LREAL:=[4(0.0)];
	
	// instrument joint control torque(when gripper is open)
	m_instruCtrlTrq:ARRAY[1..4] OF LREAL;

	// instrument yaw control torque(when gripper is closed)
	m_instruYawCtrlTrq:LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
	]]></ST>
    </Implementation>
    <Method Name="init" Id="{ad68ad31-14f3-42f4-bf27-26d385743fba}">
      <Declaration><![CDATA[METHOD init : BOOL
VAR_INPUT
	i_armIdx:INT;
END_VAR

VAR
	i,j:INT;
	currentRatioMotor2Jnt:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_armIdx:=i_armIdx;

// get current instrument orientation
m_instruCurJointData.slave_L1:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L1;
m_instruCurJointData.slave_L2:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L2;
m_instruCurJointData.slave_L3:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L3;
m_instruCurJointData.slave_L4:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L4;
m_instruCurJointData.slave_L5:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L5;
m_instruFK(effector_Joint:= m_instruCurJointData, Arm_ID:= m_armIdx, effector_space=> m_instruCurCartOri);	
m_instruTargetCartOri:=m_instruCurCartOri;
m_instruCmdCartOri:=m_instruCurCartOri;
m_graspForceLevel:=0;

// init controller
FOR i:=1 TO 4 DO
	m_instruCmdWVel[i]:=0;
	m_instruCmdJntPos[i]:=Robot_Status.Robot_Current_Joint_Position_v2[m_armIdx,i-1+Gvl_IO.L1];
	m_instruLastCmdJntPos[i]:=m_instruCmdJntPos[i];
	m_instruCmdJntVel[i]:=0;
	currentRatioMotor2Jnt:=GVL_system_parameters.arm_joint_transmition_efficiency[i-1+Gvl_IO.L1]*GVL_system_parameters.transmission_ratio[m_armIdx, i-1+Gvl_IO.L1]/1000;
	m_instruJntCtrl[i].init(GVL_system_parameters.cycle_robot,m_instruKp[i],m_instruKd[i],m_instruKi[i],
		m_instruKiLimit[i]* currentRatioMotor2Jnt,	m_instruCtrlLimit[i]*currentRatioMotor2Jnt);
END_FOR
currentRatioMotor2Jnt:=GVL_system_parameters.arm_joint_transmition_efficiency[Gvl_IO.L1]*GVL_system_parameters.transmission_ratio[m_armIdx, Gvl_IO.L1]/1000;
m_instruYawCtrl.init(GVL_system_parameters.cycle_robot,m_yawKp,m_yawKd,m_yawKi,m_yawKiLimit*currentRatioMotor2Jnt, m_yawCtrlLimit*currentRatioMotor2Jnt);]]></ST>
      </Implementation>
    </Method>
    <Method Name="run" Id="{7565c7b3-97d9-43dd-bc18-57a80d3fc9eb}">
      <Declaration><![CDATA[METHOD run : BOOL
VAR_INPUT
	// target instrument orientation in tool coordinate
	i_instruTragetCartOri:ST_effector_position_Cartesian;
	
	// grip force level
	i_gripForceLevel:UINT;
END_VAR

VAR_OUTPUT
	// motor control current
	o_cmdMotorCurrent:ARRAY[1..4] OF LREAL;
END_VAR

VAR
	i: INT;
	currentRatioMotor2Jnt:LREAL;
	maxJntTrq:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_instruTargetCartOri:=	i_instruTragetCartOri;
m_graspForceLevel:=LIMIT(0,i_gripForceLevel ,  100)	;

// get current instrument orientation
m_instruCurJointData.slave_L1:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L1;
m_instruCurJointData.slave_L2:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L2;
m_instruCurJointData.slave_L3:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L3;
m_instruCurJointData.slave_L4:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L4;
m_instruCurJointData.slave_L5:=Robot_Status.Robot_Current_Joint_Position[m_armIdx].L5;
m_instruFK(effector_Joint:= m_instruCurJointData, Arm_ID:= m_armIdx, effector_space=> m_instruCurCartOri);

// interpolate command orientation 
m_instruCmdWVel[1]:=LIMIT(-m_instruMaxWVel, (m_instruTargetCartOri.rot_x-m_instruCmdCartOri.rot_x)/GVL_system_parameters.cycle_robot,m_instruMaxWVel);
m_instruCmdWVel[2]:=LIMIT(-m_instruMaxWVel, (m_instruTargetCartOri.rot_y-m_instruCmdCartOri.rot_y)/GVL_system_parameters.cycle_robot,m_instruMaxWVel);
m_instruCmdWVel[3]:=LIMIT(-m_instruMaxWVel, (m_instruTargetCartOri.rot_z-m_instruCmdCartOri.rot_z)/GVL_system_parameters.cycle_robot,m_instruMaxWVel);
m_instruCmdWVel[4]:=LIMIT(-m_instruMaxWVel, (m_instruTargetCartOri.open_angle-m_instruCmdCartOri.open_angle)/GVL_system_parameters.cycle_robot,m_instruMaxWVel);
m_instruCmdCartOri.rot_x:=m_instruCmdCartOri.rot_x+m_instruCmdWVel[1]*GVL_system_parameters.cycle_robot;
m_instruCmdCartOri.rot_y:=m_instruCmdCartOri.rot_y+m_instruCmdWVel[2]*GVL_system_parameters.cycle_robot;
m_instruCmdCartOri.rot_z:=m_instruCmdCartOri.rot_z+m_instruCmdWVel[3]*GVL_system_parameters.cycle_robot;
m_instruCmdCartOri.open_angle:=m_instruCmdCartOri.open_angle+m_instruCmdWVel[4]*GVL_system_parameters.cycle_robot;

// calculate target instrument joint position from cartesian orientation
m_instruIK(	position_space:= m_instruCmdCartOri, Arm_ID:= 1, 
angle_slave_L1=> m_instruCmdJntPos[1], 
angle_slave_L2=> m_instruCmdJntPos[2], 
angle_slave_L3=> m_instruCmdJntPos[3], 
angle_slave_L4=> m_instruCmdJntPos[4], 
angle_slave_L5=> );

// compute target joint velocity
FOR i:=1 TO 4 DO
	m_instruCmdJntVel[i]:=(m_instruCmdJntPos[i]-m_instruLastCmdJntPos[i])/GVL_system_parameters.cycle_robot;
	m_instruLastCmdJntPos[i]:=m_instruCmdJntPos[i];
END_FOR

// joint position control torque control
FOR i:=1 TO 4 DO
	m_instruCurJntPos[i]:=Robot_Status.Robot_Current_Joint_Position_v2[m_armIdx,i-1+Gvl_IO.L1];
	m_instruCurJntVel[i]:=Robot_Status.Robot_Current_Joint_Velocity_v2_filtered[m_armIdx,i-1+Gvl_IO.L1];
	m_instruCtrlTrq[i]:=m_instruJntCtrl[i].run(m_instruCmdJntPos[i],m_instruCurJntPos[i], m_instruCmdJntVel[i], m_instruCurJntVel[i]);
END_FOR

// use motion/force share control
m_instruCurYawVel :=(Robot_Status.Robot_Current_Joint_Velocity_v2_filtered[m_armIdx,Gvl_IO.L2]-Robot_Status.Robot_Current_Joint_Velocity_v2_filtered[m_armIdx,Gvl_IO.L1])/2.0;
m_yawAngErr:=rad2deg(m_instruCmdCartOri.rot_z-m_instruCurCartOri.rot_z);
IF m_graspForceLevel >0  THEN
	// compute yaw control torque
	m_instruYawCtrlTrq:=m_instruYawCtrl.run(m_instruCmdCartOri.rot_z,m_instruCurCartOri.rot_z,m_instruCmdWVel[3], m_instruCurYawVel);
	
	// add feed forward grasp force
	currentRatioMotor2Jnt:=GVL_system_parameters.arm_joint_transmition_efficiency[Gvl_IO.L1]*GVL_system_parameters.transmission_ratio[m_armIdx, Gvl_IO.L1]/1000;
	maxJntTrq:=m_yawCtrlLimit*currentRatioMotor2Jnt;
	m_instruCtrlTrq[1]:= currentRatioMotor2Jnt*m_maxGripForce*m_graspForceLevel/100.0 - m_instruYawCtrlTrq;
	m_instruCtrlTrq[2]:= currentRatioMotor2Jnt*m_maxGripForce*m_graspForceLevel/100.0 + m_instruYawCtrlTrq;
	m_instruCtrlTrq[1]:=LIMIT(-maxJntTrq,m_instruCtrlTrq[1], maxJntTrq);
	m_instruCtrlTrq[2]:=LIMIT(-maxJntTrq,m_instruCtrlTrq[2], maxJntTrq);
END_IF

// motor control current
FOR i:=1 TO 4 DO
	o_cmdMotorCurrent[i]:=gvl_system_parameters.Joint_Motion_direction[m_armIdx,Gvl_IO.L1+i-1]*m_instruCtrlTrq[i];
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FBGripControl">
      <LineId Id="53" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FBGripControl.init">
      <LineId Id="53" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="54" Count="5" />
      <LineId Id="16" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="66" Count="0" />
      <LineId Id="43" Count="1" />
      <LineId Id="84" Count="0" />
      <LineId Id="68" Count="2" />
      <LineId Id="74" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="47" Count="0" />
    </LineIds>
    <LineIds Name="FBGripControl.run">
      <LineId Id="17" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="79" Count="6" />
      <LineId Id="78" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="18" Count="2" />
      <LineId Id="138" Count="0" />
      <LineId Id="23" Count="2" />
      <LineId Id="139" Count="0" />
      <LineId Id="33" Count="8" />
      <LineId Id="45" Count="0" />
      <LineId Id="92" Count="1" />
      <LineId Id="95" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="49" Count="0" />
      <LineId Id="51" Count="3" />
      <LineId Id="96" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="113" Count="1" />
      <LineId Id="118" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="57" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="107" Count="2" />
      <LineId Id="70" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>