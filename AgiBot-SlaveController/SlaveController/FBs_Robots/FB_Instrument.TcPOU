<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Instrument" Id="{8c0067f5-f42b-4462-b105-279d3ba7139d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Instrument

VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR

VAR
	// instrument type
	m_instruType : 	E_InstrumentType := InstruType_UNKNOWM;
	
	// instrument name
	m_instruName : STRING:= g_instruNullName;
	m_instruNameCH : WSTRING;
	
	// instrument type index, which is used to get relative parameters from global variable arrays
	m_instruTypeIdx :INT:=0;
	
	// flag if instrument is singer finger
	m_isSingleFinger:BOOL:= FALSE;
	
	//flag if instrument is energy type 
	m_isEnergyType : UINT :=0;
	
	// current and max allowed read tries
	m_curReadTries :INT :=0;
	m_maxReadTries :INT := 2;
	
	//IP of operating arm
	m_armNetId:T_AmsNetId; 	
	
	//Joint port number
	m_jointInstruAddr:UINT;	

	//Arm LED Prot	
	m_LEDPortAddr:UINT;		
	
	//The state and parameters readed from the instrument
	m_onChipData:ST_InstruOnChipData;
	
	// instrument kinematic parameters
	m_kinematicParameters:ST_InstruKinematicParam; 
	
	// joint position when instrument is at ZERO posture
	m_jntPosOffset:Vec8d;
	
	// reduction from motor joint to endoscope rotate joint
	m_endoscopeRotateReduction :LREAL := 2.0/3.0;
	
	//endoscope type
	m_curEndoscopeType :E_EndoscopeType:=EndoScopeType_30;
	m_nextEndoscopeType :E_EndoscopeType:=EndoScopeType_30;
	
	//endoscope posutre
	m_curEndoscopePosture :E_EndoscopePosture:=EndoscopePosture_HeadDown;
	m_nextEndoscopePosture :E_EndoscopePosture:=EndoscopePosture_HeadDown;
	
	// udint code for zero position
	m_zeroPosCode : UDINT;
	
	// joint4 zero position, which is supposed to be a contant value
	m_jnt4ZeroPos :LREAL := 5.7;
	
	//reset arm  LED flag
	m_resetArmLEDFlag : BOOL :=TRUE;
	
	// variables used to read instrument information
	m_Step:INT;
	m_Value:UDINT;
	m_ReadDelay:TON;
	m_DealyTime:TIME:=T#0.5S;
	m_IDReadResult:UDINT;
	m_IDResult:ULINT;
	m_SeriesReadResult:UDINT;
	m_PosReadResult:UDINT;
	m_PosL1,m_PosL2,m_PosL3:UDINT;
	m_signL1,m_signL2,m_signL3:UDINT;
	m_UsageReadResult:ULINT;
	m_InstruUsageToLED:ULINT;
	m_InstruSeriesRecord:ARRAY [1..100] OF ULINT;
	m_HaveRecord:BOOL;
	m_SdoWrite:FB_EcCoESdoWrite;
	m_SdoRead:FB_EcCoESdoRead;
	
	//variables used to read-write instrument number of use
	m_useNumStep : INT;
	m_ReadNumDelay:TON;
	m_useNumReadResult:ULINT;
	m_useNumSendToLED:ULINT;
	
	// rising edge generator for instrument information reading
	m_writeLDP:R_TRIG;
	
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="property" Id="{9d49480e-8469-42fe-9794-09bbda49b553}" />
    <Method Name="checkInstruType" Id="{97020e4c-24ed-4bb8-b0ec-bca5a733a6da}">
      <Declaration><![CDATA[METHOD PROTECTED checkInstruType : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// search instrument type
m_instruTypeIdx:=0;
FOR i:=1 TO g_instruTypesNum DO
	IF g_instruIDs[i] = m_onChipData.m_InstruID THEN
		m_instruTypeIdx := i;
		EXIT;
	END_IF
END_FOR

// return directly if instrument ID is invalid
checkInstruType := m_instruTypeIdx >0;
IF NOT(checkInstruType) THEN
	RETURN;
END_IF

// instrument type and name
m_instruType := m_onChipData.m_InstruID;
m_instruName :=GVL_InstruCtrlParams.g_instruNameString[m_instruTypeIdx];
m_instruNameCH := GVL_InstruCtrlParams.g_instruNameStringCH[m_instruTypeIdx];

// check if instrument has one finger
m_isSingleFinger :=  (m_instruType = InstruType_CauteryHook OR  m_instruType = InstruType_CauterySpatula );

// check the type of energy instrument
IF m_instruType = InstruType_CurvedScissors OR m_instruType = InstruType_CauteryHook OR m_instruType = InstruType_CauterySpatula THEN
	m_isEnergyType := 1;
ELSIF m_instruType = InstruType_MarylandForceps OR m_instruType = InstruType_FenestratedForceps THEN
	m_isEnergyType := 2;
ELSIF m_instruType = InstruType_UltrasoundKnifeS OR m_instruType = InstruType_UltrasoundKnifeU THEN
	m_isEnergyType := 3;
ELSE
	m_isEnergyType := 0;
END_IF


// update instrument kinematic parameters based on readed info
IF m_instruTypeIdx > 0 THEN
	m_kinematicParameters.m_maxGripAngle := g_instruMaxGripAngle[m_instruTypeIdx];
	
	m_kinematicParameters.k13:=k13[m_instruTypeIdx];
	m_kinematicParameters.k23:=k23[m_instruTypeIdx];
	m_kinematicParameters.kx:=kx[m_instruTypeIdx];
	m_kinematicParameters.ky:=ky[m_instruTypeIdx];
	m_kinematicParameters.kz:=kz[m_instruTypeIdx];
			
	m_kinematicParameters.m_rodLength := GVL_InstruCtrlParams.g_instruRodLength[m_instruTypeIdx] - GVL_SlaveArmKinematic.g_panelHeight;
	m_kinematicParameters.m_headLength := GVL_InstruCtrlParams.g_instruHeadLength[m_instruTypeIdx];
	m_kinematicParameters.m_fingerLength := GVL_InstruCtrlParams.g_instruFingerLength[m_instruTypeIdx];

	m_kinematicParameters.m_wristMinDHJntPos[2]:=-GVL_InstruCtrlParams.g_instruMaxPitchAngle[m_instruTypeIdx]-pi/2;
	m_kinematicParameters.m_wristMaxDHJntPos[2]:=GVL_InstruCtrlParams.g_instruMaxPitchAngle[m_instruTypeIdx]-pi/2;
	m_kinematicParameters.m_wristMinDHJntPos[3]:=-GVL_InstruCtrlParams.g_instruMaxYawAngle[m_instruTypeIdx];
	m_kinematicParameters.m_wristMaxDHJntPos[3]:=GVL_InstruCtrlParams.g_instruMaxYawAngle[m_instruTypeIdx];

END_IF


]]></ST>
      </Implementation>
    </Method>
    <Property Name="curScopePosture" Id="{c327ac7d-1ff6-4f6a-8d7d-377863afa9ff}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY curScopePosture : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{3340ac94-9c36-4f32-8601-dac4725b2a6d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[curScopePosture:= m_curEndoscopePosture;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f31b6899-d58a-4db8-8485-bf28ba7830a5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_curEndoscopePosture := curScopePosture;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="curScopeType" Id="{4bce8a98-2eb7-4bb1-9eae-0e7d18b990ab}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY curScopeType : E_EndoscopeType]]></Declaration>
      <Get Name="Get" Id="{abceb35e-0bca-4bf2-b494-bd59bc26f3c4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[curScopeType := m_curEndoscopeType;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b042366b-dcc9-4e34-ab02-a26f6cf69d06}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_curEndoscopeType := curScopeType;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="gripAngleMap" Id="{b8d7e03a-0cbe-42c6-a7e6-6b03109deb8f}">
      <Declaration><![CDATA[METHOD PUBLIC gripAngleMap : BOOL
VAR_INPUT
	// master gripper angle
	i_masterGripAng :LREAL;
END_VAR

VAR_OUTPUT
	// slave instrument gripper angle
	o_instruGripAngle :LREAL;
	
	// slave instrument grip force	
	o_instruGripForceLevel :LREAL;
END_VAR

VAR
	gripLevel :REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// suppose finger is  closed and zero force if instrument has only one finger
IF m_isSingleFinger THEN
	o_instruGripAngle := 0;
	o_instruGripForceLevel:= 0;
	RETURN;
END_IF 

// finger closed and force applied
IF i_masterGripAng < g_masterGripForceStartAng THEN
	o_instruGripAngle := m_kinematicParameters.m_minGripAngle;
	// NOTE: force is applied from 50%，as minimum gripper angle already apply some sort of force
	o_instruGripForceLevel := 50+50*(g_masterGripForceStartAng - i_masterGripAng)/(g_masterGripForceStartAng - g_minMasterGripAngle);
// finger open
ELSE
	o_instruGripAngle := (g_maxMasterGripAngle - i_masterGripAng)/(g_maxMasterGripAngle - g_masterGripForceStartAng);
	o_instruGripAngle :=m_kinematicParameters.m_maxGripAngle - o_instruGripAngle * (m_kinematicParameters.m_maxGripAngle - m_kinematicParameters.m_minGripAngle);
	o_instruGripForceLevel:=0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{b6799ae1-8e52-4442-8aea-44a9f33a3afc}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_INPUT
	armIdx :INT;
END_VAR
VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Update the IP and port number of the operating arm
m_armNetId:=GVL_SlaveJointEncoderCaliData.g_slaveArmNetID[armIdx];
m_jointInstruAddr:=GVL_SlaveJointEncoderCaliData.g_slaveJointNetPort[armIdx,4];

// init joint motion range
FOR i:=1 TO 3 DO
	m_kinematicParameters.m_wristMinDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i+3];
	m_kinematicParameters.m_wristMaxDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i+3];
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="initInstruJntPos" Id="{9abce61f-f34d-42ca-a401-a8190ac28e6c}">
      <Declaration><![CDATA[METHOD PUBLIC initInstruJntPos : BOOL
VAR_INPUT
	m_curJntPos :Vec8d;
END_VAR

VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=m_curJntPos[i];
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruFK" Id="{097c05ed-881a-44a5-815d-27300cef479f}">
      <Declaration><![CDATA[// convert motor joint position to DH joint position
METHOD PUBLIC instruFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint position of slave arm
	i_jntPos :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint positon
	r_DHJntPos :Vec6d;

	// gripper angle
	r_gripAngle :LREAL;
END_VAR

VAR
	jntPosL1,jntPosL2,jntPosL3,jntPosL4,jntPosL5 :LREAL;
	gripAngle:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntPos[1]:=i_jntPos[1];
r_DHJntPos[2]:=i_jntPos[2];
r_DHJntPos[3]:=i_jntPos[3];

// ################## endoscope ############################
IF m_instruType = InstruType_endoscope THEN
	r_DHJntPos[4]:=m_endoscopeRotateReduction*(i_jntPos[8]-m_jntPosOffset[8]);
	IF m_curEndoscopeType = EndoScopeType_30 THEN
		r_DHJntPos[5]:=-pi/2+30*g_deg2Rad;
	ELSE
		r_DHJntPos[5]:=-pi/2;
	END_IF
	r_DHJntPos[6]:=0;
	RETURN;
END_IF

// ################## ultrosonic knief ############################
IF m_instruType = InstruType_UltrasoundKnifeS OR m_instruType = InstruType_UltrasoundKnifeU THEN
	r_DHJntPos[4]:=-(i_jntPos[8]-m_jntPosOffset[8])/m_kinematicParameters.kx;
	r_DHJntPos[5]:=-pi/2;
	r_DHJntPos[6]:=0;
	RETURN;
END_IF


//#################### instrument forward kinematic ############
// convert motor joint position to instrument joint position
jntPosL1:=(i_jntPos[4]-m_jntPosOffset[4]);
jntPosL2:=(i_jntPos[5]-m_jntPosOffset[5]);
jntPosL3:=(i_jntPos[6]-m_jntPosOffset[6]);
jntPosL4:=-(i_jntPos[7]-m_jntPosOffset[7]);
jntPosL5:=-(i_jntPos[8]-m_jntPosOffset[8]);

// diable L1 if instrument is single finger
IF m_isSingleFinger THEN
	jntPosL1 := -jntPosL2;
END_IF

// instrument FK in local coordinate
r_DHJntPos[4]:=jntPosL4/m_kinematicParameters.kx;
r_DHJntPos[5]:=jntPosL3/m_kinematicParameters.ky;
r_DHJntPos[6]:=(jntPosL1-jntPosL2-2*r_DHJntPos[5]*m_kinematicParameters.k13*m_kinematicParameters.kz)/(2*m_kinematicParameters.m_openAngleDir*m_kinematicParameters.kz);

// convert instrument rotation to arm DH joint position
r_DHJntPos[5]:=-r_DHJntPos[5]-pi/2;
r_DHJntPos[6]:=-r_DHJntPos[6];

// grip angle
gripAngle:=(jntPosL1+jntPosL2)/(m_kinematicParameters.m_openAngleDir*m_kinematicParameters.kz);

//################### gripper angle handle #################
IF (InstruType_ProGraspForceps=m_instruType) THEN//细齿无创抓钳
	proGrsapForcepsGripAngleFK(frontAngle:= gripAngle, endAngle=> r_gripAngle);

ELSIF (InstruType_CauteryHook = m_instruType) THEN//单级电钩
	r_gripAngle:=0;
	
ELSIF InstruType_UltrasoundKnifeS = onChipData.m_InstruID OR InstruType_UltrasoundKnifeU = onChipData.m_InstruID THEN
	r_gripAngle:=ultrasoundKnifeGripAngleFK(jntPosL3);
	
ELSE
	r_gripAngle:=gripAngle;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruIDRecord" Id="{f3567262-d84c-4741-97fb-36ae0b451ee9}">
      <Declaration><![CDATA[METHOD PROTECTED InstruIDRecord :ARRAY [1..100] OF  ULINT
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
END_VAR

VAR
	k1:INT;
	Have_Data:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		Have_Data:=TRUE;
		EXIT;
	ELSE
		Have_Data:=FALSE;
	END_IF
END_FOR

IF Have_Data=FALSE THEN
	FOR k1:= 1 TO 99 BY 1 DO
		InstruIDRecord[k1+1]:=i_ArrayData[k1];
	END_FOR
	InstruIDRecord[1]:=i_NewValue;
ELSE
	InstruIDRecord:=i_ArrayData ;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruIK" Id="{9a18f93c-de08-4a8c-a2e3-32833c619719}">
      <Declaration><![CDATA[METHOD PUBLIC instruIK : BOOL
VAR_INPUT
	// DH  joint positon
	i_DHJntPos :Vec6d;

	// gripper angle
	i_gripAngle :LREAL;
	
END_VAR
VAR_OUTPUT
	o_jntPos:Vec8d;
END_VAR
VAR
	gripAngle:LREAL;
	i:INT;
	rot_x:lreal;
	rot_y:lreal;
	rot_z:lreal;

	kx,ky,kz,k13,k23:LREAL;
	open_direction:INT;
	
	d,ra:LREAL;
	AngleOffsetL3:LREAL;
	m_targetOffsetL3:LREAL;
	m_actOffsetL3:LREAL;
	
	m_gripAnglePbox:Vec8d;

	L3Offset:LREAL:=-3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[o_jntPos[1] := i_DHJntPos[1];
o_jntPos[2] := i_DHJntPos[2];
o_jntPos[3] := i_DHJntPos[3];

// ################## endoscope ############################
IF m_instruType = InstruType_endoscope THEN
	o_jntPos[8] := i_DHJntPos[4]/m_endoscopeRotateReduction + m_jntPosOffset[8];
	o_jntPos[4]:=0;
	o_jntPos[5]:=0;
	o_jntPos[6]:=0;
	o_jntPos[7]:=0;
	RETURN;
END_IF

//################### gripper angle handle #################
IF (12=onChipData.m_InstruID) THEN//细齿无创抓钳
	proGrsapForcepsGripAngleIK(endAngle:= i_gripAngle, frontAngle=> gripAngle);
	
ELSIF 16 = onChipData.m_InstruID THEN//单级电钩\电铲
	gripAngle:=0;
	
ELSE
	gripAngle:=i_gripAngle;
END_IF

// ################# instrument inverse kinematic ##############
// convert arm DH joint position to  instrument rotation
rot_x:=i_DHJntPos[4];
rot_y:=-i_DHJntPos[5]-pi/2;
rot_z:=-i_DHJntPos[6];

// instrument IK in local coordinate
k13:=m_kinematicParameters.k13;
k23:=m_kinematicParameters.k23;
kx:=m_kinematicParameters.kx;
ky:=m_kinematicParameters.ky;
kz:=m_kinematicParameters.kz;
d:=m_kinematicParameters.m_openAngleDir;

// ################## ultrosonic knief ############################
IF InstruType_UltrasoundKnifeS = onChipData.m_InstruID OR InstruType_UltrasoundKnifeU = onChipData.m_InstruID THEN
	m_gripAnglePbox[4]:=0;
	m_gripAnglePbox[5]:=0;
	m_gripAnglePbox[6]:=ultrasoundKnifeGripAngleIK(gripAngle); 
	m_gripAnglePbox[7]:=rot_x*kx;
	m_gripAnglePbox[8]:=rot_x*kx;
ELSE
	m_gripAnglePbox[7]:=rot_x*kx;
	m_gripAnglePbox[6]:=rot_y*ky;
	ra:=gripAngle;
	m_gripAnglePbox[4]:=rot_y*k13*kz+d*rot_z*kz+d*ra*kz/2;
	m_gripAnglePbox[5]:=-rot_y*k23*kz-d*rot_z*kz+d*ra*kz/2;
END_IF

// convert instrument joint position to motor joint position
o_jntPos[4] := m_gripAnglePbox[4] + m_jntPosOffset[4];
o_jntPos[5] := m_gripAnglePbox[5] + m_jntPosOffset[5];
o_jntPos[6] := m_gripAnglePbox[6] + m_jntPosOffset[6];
o_jntPos[7] := -m_gripAnglePbox[7] + m_jntPosOffset[7];
o_jntPos[8] := -m_gripAnglePbox[8] + m_jntPosOffset[8];


]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruJntVelFK" Id="{a9276aa2-9909-457e-91a6-03a2e37295b6}">
      <Declaration><![CDATA[// convert motor joint velocity to DH joint velocity
METHOD PUBLIC instruJntVelFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint velocity of slave arm
	i_jntVel :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint velocity
	r_DHJntVel :Vec6d;
END_VAR

VAR
	jntPosL1,jntPosL2,jntPosL3,jntPosL4,jntPosL5 :LREAL;
	gripAngle:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntVel[1]:=i_jntVel[1];
r_DHJntVel[2]:=i_jntVel[2];
r_DHJntVel[3]:=i_jntVel[3];

r_DHJntVel[4]:=-i_jntVel[7]/m_kinematicParameters.kx;
r_DHJntVel[5]:=i_jntVel[6]/m_kinematicParameters.ky;
r_DHJntVel[6]:=(i_jntVel[4]-i_jntVel[5]-2*r_DHJntVel[5]*m_kinematicParameters.k13*m_kinematicParameters.kz)/(2*m_kinematicParameters.m_openAngleDir*m_kinematicParameters.kz);
r_DHJntVel[5]:=-r_DHJntVel[5];
r_DHJntVel[6]:=-r_DHJntVel[6];]]></ST>
      </Implementation>
    </Method>
    <Property Name="instruName" Id="{483b355d-6396-4702-92b6-d3c009619627}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY instruName : String]]></Declaration>
      <Get Name="Get" Id="{3c4e31c2-6928-4ddc-bd08-7af3cec37927}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruName := m_instruName;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="instruNameCH" Id="{fe4ca7cf-bcad-49ba-86fd-3ae926574c61}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY instruNameCH : WSTRING]]></Declaration>
      <Get Name="Get" Id="{27367f18-af3a-4bb4-875f-a9cbdbda8e9f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruNameCH := m_instruNameCH;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="InstruSreiesFind" Id="{f880300d-e9dd-456f-88b6-72b1cc8bd3d5}">
      <Declaration><![CDATA[METHOD PROTECTED InstruSreiesFind : BOOL
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
	
END_VAR

VAR
	k1:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[InstruSreiesFind:=FALSE;
FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		InstruSreiesFind:=TRUE;
		EXIT;
	ELSE
		InstruSreiesFind:=FALSE;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Property Name="instruType" Id="{dee9b466-61c8-4830-8c3c-8317ba8d7fb1}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY PUBLIC instruType : INT]]></Declaration>
      <Get Name="Get" Id="{49e23c7c-bb55-4631-aecb-7cce8ba4d643}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[instruType := m_instruType;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="isEnergyType" Id="{7287771d-2f2c-4934-9b23-a12078d9e1e2}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY isEnergyType : UINT
]]></Declaration>
      <Get Name="Get" Id="{0252a723-f3c1-41a2-b14a-db4932941c3c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[isEnergyType := m_isEnergyType;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="kinematicParameters" Id="{e7ad17bd-82e9-477e-9e66-6a8feac51534}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY kinematicParameters :REFERENCE TO ST_InstruKinematicParam]]></Declaration>
      <Get Name="Get" Id="{d0447347-931d-4e2e-81b2-c8e4acc99fd6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[kinematicParameters ref=m_kinematicParameters;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="nextScopePosture" Id="{48ece37f-c5c3-453e-afe5-8c33fe7eb315}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY nextScopePosture : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{07de26d8-dacc-432f-85c8-f04024d47afd}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nextScopePosture:= m_nextEndoscopePosture;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{33462dd0-4b03-403d-a99e-110b0590fa7e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_nextEndoscopePosture := nextScopePosture;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="nextScopeType" Id="{dca96b48-db31-4f08-81c0-25e9bd0712eb}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY nextScopeType : E_EndoscopePosture]]></Declaration>
      <Get Name="Get" Id="{815f56b6-cf18-45a1-a9a3-a7d0c73baa6e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nextScopeType:= m_nextEndoscopeType;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{a373dd0f-9a3d-404d-a5d3-2cea57ae861a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_nextEndoscopeType := nextScopeType;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="onChipData" Id="{093a4217-bb32-41a8-a667-4570e97851b1}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY onChipData : REFERENCE TO ST_InstruOnChipData]]></Declaration>
      <Get Name="Get" Id="{f9328823-d656-4b2e-b51e-d2d3d6c6297d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[onChipData ref=m_onChipData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="proGrsapForcepsGripAngleFK" Id="{d3dda96d-7b55-4cf3-9ffe-c8cf53ace77d}">
      <Declaration><![CDATA[METHOD PROTECTED proGrsapForcepsGripAngleFK : BOOL
VAR_INPUT
	frontAngle:LREAL;
END_VAR
VAR_OUTPUT
	endAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	minFrontAng :LREAL  := 16.6*2*g_deg2Rad;
	maxFrontAng :LREAL := 49.18*2*g_deg2Rad;
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	Angle_Initial_A:LREAL := 16.6 * g_deg2Rad; 
	SIN_C,Angle_Initial_C,End_Angle_Single,Angle_Inc_C,Angle_C,SIN_A,Angle_A,Angle_Inc_A:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//**************已知：器械前端开合角，求解：末端开合角***************//

//输入合法性判断，物理极限是[16.6*2，49.18*2]度
frontAngle := LIMIT(minFrontAng, frontAngle, maxFrontAng);


SIN_C:=AB*SIN(Angle_Initial_A)/BC;
Angle_Initial_C:=ASIN(SIN_C);

Angle_Inc_A:=frontAngle/2;
Angle_A:=Angle_Initial_A+Angle_Inc_A;

SIN_C:=AB*SIN(Angle_A)/BC;
Angle_C:=ASIN(SIN_C);

Angle_Inc_C:=Angle_C-Angle_Initial_C;
endAngle:=Angle_Inc_C*2;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="proGrsapForcepsGripAngleIK" Id="{d41bf91a-0d5c-464e-b520-ee71cb3a1637}">
      <Declaration><![CDATA[METHOD PROTECTED proGrsapForcepsGripAngleIK : BOOL
VAR_INPUT
	endAngle:LREAL;
END_VAR
VAR_OUTPUT
	frontAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	minEndAng :LREAL  := 0;
	maxEndAng :LREAL := 38*g_deg2Rad;
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	Angle_Initial_A:LREAL := 16.6 * g_deg2Rad; 
	
	SIN_C,Angle_Initial_C,End_Angle_Single,Angle_Inc_C,Angle_C,SIN_A,Angle_A,Angle_Inc_A:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//***************已知：器械末端开合角，求解：前端开合角********************//

//输入合法性判断，物理极限是[0,30]度
endAngle:= LIMIT(minEndAng, endAngle, maxEndAng);

SIN_C:=AB*SIN(Angle_Initial_A)/BC;
Angle_Initial_C:=ASIN(SIN_C);

End_Angle_Single:=endAngle/2;
Angle_Inc_C:=End_Angle_Single;
Angle_C:=Angle_Initial_C+Angle_Inc_C;

SIN_A:=BC*SIN(Angle_C)/AB;
Angle_A:=ASIN(SIN_A);

Angle_Inc_A:=Angle_A-Angle_Initial_A;
frontAngle:=Angle_Inc_A*2;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="readParameters" Id="{fafb5a79-7caf-47d4-9d2f-b3dbd95048cf}">
      <Declaration><![CDATA[METHOD PUBLIC readParameters : BOOL
VAR_INPUT
	startFlag :BOOL;
END_VAR

VAR
	paramIdx :INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: read m_kinematic parameters from chip 
//Take the rising edge of the read signal
m_ReadDelay(IN:= m_Step=10, PT:= m_DealyTime, Q=> , ET=> );//计时器
IF startFlag AND m_curReadTries < m_maxReadTries THEN
	m_Step:=0;
	m_onChipData.m_InstruReadSucceed:=FALSE;
	m_onChipData.m_Error:=FALSE;
	m_onChipData.m_ErrorID:=0;
	m_resetArmLEDFlag :=TRUE;
END_IF


CASE m_Step OF
	
	0://向6093发送0x8000  0000---发送读取信号
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6093, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=10;
		END_IF
		
		
	10://延时0.5s、防止值还没有返回
		IF m_ReadDelay.Q THEN
			m_Step:=20;
		END_IF

		
	20://从6093地址中拿值
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6093, pDstBuf:= ADR(m_IDReadResult), cbBufLen:= SIZEOF(m_IDReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=30;
		END_IF	
		
	
	30://处理器械ID、低16位
		m_IDResult:=UDINT_TO_ULINT(16#0000FFFF AND m_IDReadResult);
		m_Step:=40;
		
		
	40://读取6095、器械序列号
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6095, pDstBuf:= ADR(m_SeriesReadResult), cbBufLen:= SIZEOF(m_SeriesReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=50;
		END_IF	
	
		
	50://处理序列号，低30位
		m_onChipData.m_InstruseriesNum:=SHL(m_IDResult,31)+(16#7FFFFFFF AND m_SeriesReadResult);
		m_onChipData.m_InstruID:=LREAL_TO_INT(FLOOR(lr_in:= m_onChipData.m_InstruseriesNum/EXPT(10,9))); //取十进制前三位为器械ID
		m_Step:=60;
		
		
	60://读取6096---器械零点位置
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6096, pDstBuf:= ADR(m_PosReadResult), cbBufLen:= SIZEOF(m_PosReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=70;
		END_IF	
		
		
	70: //处理位置，L1:0-9位，L2:10-19位，L3:20-29位
		zeroPosDecode(m_PosReadResult, o_q1=>m_onChipData.m_InstruPos[1],o_q2=>m_onChipData.m_InstruPos[2],o_q3=>m_onChipData.m_InstruPos[3]);
		m_onChipData.m_InstruPos[4] := m_jnt4ZeroPos;
		m_onChipData.m_InstruPos[5] := 0;
		
		m_Step:=80;
		
	80://读取器械使用次数 6094
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_UsageReadResult), cbBufLen:= SIZEOF(m_UsageReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=90;
		END_IF	
		
		
	90://处理器械使用次数读取结果
		m_onChipData.m_InstruusageCounts:=m_UsageReadResult;
		m_InstruUsageToLED:=LIMIT(0,m_UsageReadResult,99);
		m_Step:=100;
		
		
	100://将器械使用次数写入LED
		m_Value:=ULINT_TO_UDINT(16#FFFF AND m_InstruUsageToLED) ;
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= 1004, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=110;
		END_IF
		
	110://处理当器械使用次数达到上限后、在同一场手术中还能使用
		IF m_onChipData.m_InstruusageCounts=m_onChipData.m_InstrumaxUsageCounts THEN		
			//TODO: check this part
			m_InstruSeriesRecord:=InstruIDRecord(i_NewValue:= m_onChipData.m_InstruusageCounts, i_ArrayData:= m_InstruSeriesRecord);
		END_IF
		m_Step:=120;
		
		
	120://结果诊断
		m_onChipData.m_ErrorID:=0;
		m_onChipData.m_InstruReadSucceed:=checkInstruType();
		IF NOT(m_onChipData.m_InstruReadSucceed) THEN
			m_onChipData.m_Error:=TRUE;
			m_onChipData.m_ErrorID:=1;
			
		ELSIF SlaveArmControl.m_slaveRobot.m_endoscopeMounted AND m_instruType = InstruType_Endoscope THEN
			m_onChipData.m_InstruReadSucceed := FALSE;
			m_onChipData.m_Error:=TRUE;
			m_onChipData.m_ErrorID:=3;
			
		ELSIF m_onChipData.m_InstruusageCounts>m_onChipData.m_InstrumaxUsageCounts AND m_onChipData.m_InstruID<>20 THEN
			m_HaveRecord:=InstruSreiesFind(i_NewValue:=m_onChipData.m_InstruseriesNum , i_ArrayData:=m_InstruSeriesRecord );
			IF m_HaveRecord THEN
				//
			ELSE
				m_onChipData.m_InstruReadSucceed := FALSE;
				m_onChipData.m_Error:=TRUE;
				m_onChipData.m_ErrorID:=2;
			END_IF
		END_IF
		m_Step :=-1;
		m_curReadTries := m_curReadTries +1;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{90292eaa-1cc4-4b19-b4f6-6bcd7c03eb33}">
      <Declaration><![CDATA[METHOD PUBLIC reset : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_Step := -1;
m_curReadTries := 0;
m_onChipData.m_InstruID := 0;
m_onChipData.m_InstruseriesNum :=0;
m_onChipData.m_Error:=FALSE;
m_onChipData.m_ErrorID:=0;
m_onChipData.m_InstruReadSucceed:=FALSE;
m_isSingleFinger:=FALSE;
m_isEnergyType := 0;
m_instruType:=InstruType_UNKNOWM;
m_instruName := g_instruNullName;
m_instruTypeIdx := 0 ;

FOR i:= 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=0;
END_FOR

// init joint motion range
FOR i:=1 TO 3 DO
	m_kinematicParameters.m_wristMinDHJntPos[i]:=GVL_SlaveMotorParameters.g_minDHJntPos[i+3];
	m_kinematicParameters.m_wristMaxDHJntPos[i]:=GVL_SlaveMotorParameters.g_maxDHJntPos[i+3];
END_FOR

// reset endoscope type and posture
m_curEndoscopeType :=EndoScopeType_30;
m_nextEndoscopeType :=EndoScopeType_30;
m_curEndoscopePosture :=EndoscopePosture_HeadDown;
m_nextEndoscopePosture :=EndoscopePosture_HeadDown;

//arm LED reset
IF m_resetArmLEDFlag THEN
	m_Value:=0 ;
	m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= 1004, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
END_IF
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	m_resetArmLEDFlag := FALSE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="resetArmLED" Id="{71d71091-a005-44ba-bc61-7d4e51a8100a}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY resetArmLED : BOOL]]></Declaration>
      <Set Name="Set" Id="{0e15a6e1-bfbd-4e2e-955b-940522cefd73}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_resetArmLEDFlag := resetArmLED;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="ultrasoundKnifeGripAngleFK" Id="{1dc50a9a-b451-47d4-9f26-74d3cb81d7ff}">
      <Declaration><![CDATA[METHOD ultrasoundKnifeGripAngleFK : LREAL
VAR_IN_OUT CONSTANT
	// motor joint position of slave arm
	i_jntPos :LREAL;
END_VAR

VAR
	m_jntPos : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
m_jntPos := i_jntPos;

m_jntPos := LIMIT (-20*g_deg2Rad,m_jntPos,70*g_deg2Rad);

ultrasoundKnifeGripAngleFK := ASIN((m_jntPos*g_uknifeMotorLead * g_uknifeLeverRatio/(2*pi) -  g_uknifeGripTravel * SIN(g_uknifeGripDividAngle))/g_uknifeGripTravel)+g_uknifeGripDividAngle;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ultrasoundKnifeGripAngleIK" Id="{540a0ddb-6d91-4142-b9a4-ee974de5f7d5}">
      <Declaration><![CDATA[METHOD ultrasoundKnifeGripAngleIK : LREAL
VAR_INPUT
	// gripper angle
	i_gripAngle :LREAL;
END_VAR

VAR
	m_gripAngle : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
m_gripAngle := i_gripAngle;

ultrasoundKnifeGripAngleIK := (g_uknifeGripTravel * (SIN(g_uknifeGripDividAngle) - SIN(g_uknifeGripDividAngle - m_gripAngle))/(g_uknifeMotorLead*g_uknifeLeverRatio/(2*pi)));]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeNumOfUseToChip" Id="{c72f85d3-5b0f-42d8-878f-c490a6c1ecdf}">
      <Declaration><![CDATA[METHOD writeNumOfUseToChip : BOOL
VAR_INPUT
	startFlag :BOOL;
	i_useNumFromUI :UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
writeNumOfUseToChip := FALSE;
m_writeLDP(CLK:= startFlag, Q=> );
m_ReadNumDelay(IN:= m_useNumStep = 10, PT:= m_DealyTime, Q=> , ET=> );
IF m_writeLDP.Q THEN
	m_useNumStep:=0;
END_IF

CASE m_useNumStep OF
	0: 
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6094, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_useNumStep:=10;
		END_IF
	
	10:
		IF m_ReadNumDelay.Q THEN
			m_useNumStep:=20;
		END_IF
		
	20:
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_useNumReadResult), cbBufLen:= SIZEOF(m_useNumReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_useNumStep:=30;
		END_IF
		
	30://Verify the actual usage count and the usage count given by the UI
		IF m_useNumReadResult = i_useNumFromUI THEN
			m_useNumSendToLED := LIMIT(0, m_useNumReadResult, 99);
			m_useNumStep:=40;
		ELSE
			m_useNumStep:=50;
		END_IF
		
	40: 
		m_Value:=ULINT_TO_UDINT( m_useNumSendToLED) ;
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= 1004, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_onChipData.m_InstruUsageCounts:=m_useNumReadResult;
			writeNumOfUseToChip := TRUE;
			m_useNumStep:=-1;
		END_IF
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="writeZeroPosToChip" Id="{bd19b6c1-405e-4351-971f-f03bf3bea173}">
      <Declaration><![CDATA[METHOD PUBLIC writeZeroPosToChip : BOOL
VAR_INPUT
	i_q1:LREAL;
	i_q2:LREAL;
	i_q3:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[zeroPosCode(i_q1,i_q2,i_q3, o_code=>m_zeroPosCode);

writeZeroPosToChip:=FALSE;
m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6096, pSrcBuf:= ADR(m_zeroPosCode), cbBufLen:= SIZEOF(m_zeroPosCode), bExecute:= TRUE, );
IF NOT m_SdoWrite.bBusy THEN
	m_SdoWrite(bExecute:=FALSE);
	writeZeroPosToChip:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="zeroPosCode" Id="{84c93418-be66-4d42-a7c9-9496164ac08f}">
      <Declaration><![CDATA[// code instrument joints(4/5/6) zero position as a UDINT
// joint1 : bit 21-30; joint2: bit 11-20; joint3: bit1-10
// zeroPos: [0, 2pi]; code:[0-3sFF]
METHOD PROTECTED zeroPosCode : BOOL
VAR_INPUT
	i_q1:LREAL;
	i_q2:LREAL;
	i_q3:LREAL;
END_VAR
VAR_OUTPUT
	o_code:UDINT;
END_VAR
VAR
	posCode:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// highest bit set to 1
o_code:=2;

// joint1
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q1/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;

// joint2
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q2/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;

// joint3
posCode := LREAL_TO_UDINT(16#3FF * LIMIT(0,i_q3/g_2pi,1));
o_code := SHL(o_code, 10);
o_code := o_code OR posCode;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="zeroPosDecode" Id="{7d5604d0-0288-46b2-b433-10a7497ca58f}">
      <Declaration><![CDATA[// decode instrument joints(4/5/6) zero position from a UDINT
// joint1 : bit 21-30; joint2: bit 11-20; joint4: bit1-10
// zeroPos: [0, 2pi]; code:[0-2FF]
METHOD PROTECTED zeroPosDecode : BOOL
VAR_INPUT
	i_posCode :UDINT;
END_VAR
VAR_OUTPUT
	o_q1:LREAL;
	o_q2:LREAL;
	o_q3:LREAL;
END_VAR
VAR
	posCode:UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// joint3
posCode := i_posCode AND 16#3FF;
o_q3 := g_2pi *  posCode/16#3FF;

// joint2
i_posCode := SHR(i_posCode, 10);
posCode := i_posCode AND 16#3FF;
o_q2 := g_2pi *  posCode/16#3FF;

// joint1
i_posCode := SHR(i_posCode, 10);
posCode := i_posCode AND 16#3FF;
o_q1 := g_2pi *  posCode/16#3FF;
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Instrument">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.checkInstruType">
      <LineId Id="274" Count="56" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopePosture.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopePosture.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopeType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.curScopeType.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.gripAngleMap">
      <LineId Id="80" Count="0" />
      <LineId Id="83" Count="3" />
      <LineId Id="82" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="26" Count="3" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.init">
      <LineId Id="7" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.initInstruJntPos">
      <LineId Id="9" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="1" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruFK">
      <LineId Id="319" Count="14" />
      <LineId Id="394" Count="3" />
      <LineId Id="401" Count="0" />
      <LineId Id="403" Count="2" />
      <LineId Id="393" Count="0" />
      <LineId Id="334" Count="39" />
      <LineId Id="159" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruIDRecord">
      <LineId Id="12" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruIK">
      <LineId Id="589" Count="61" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruJntVelFK">
      <LineId Id="131" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="200" Count="3" />
      <LineId Id="159" Count="0" />
      <LineId Id="220" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruName.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruNameCH.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruSreiesFind">
      <LineId Id="34" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.isEnergyType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.kinematicParameters.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopePosture.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopePosture.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopeType.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.nextScopeType.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.onChipData.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.proGrsapForcepsGripAngleFK">
      <LineId Id="6" Count="3" />
      <LineId Id="44" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="20" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.proGrsapForcepsGripAngleIK">
      <LineId Id="12" Count="3" />
      <LineId Id="54" Count="0" />
      <LineId Id="24" Count="13" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.readParameters">
      <LineId Id="837" Count="1" />
      <LineId Id="705" Count="38" />
      <LineId Id="836" Count="0" />
      <LineId Id="745" Count="83" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.reset">
      <LineId Id="51" Count="1" />
      <LineId Id="5" Count="1" />
      <LineId Id="11" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="124" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="41" Count="4" />
      <LineId Id="39" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="102" Count="1" />
      <LineId Id="121" Count="2" />
      <LineId Id="131" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.resetArmLED.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.ultrasoundKnifeGripAngleFK">
      <LineId Id="3" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.ultrasoundKnifeGripAngleIK">
      <LineId Id="3" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeNumOfUseToChip">
      <LineId Id="54" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="6" Count="2" />
      <LineId Id="5" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="20" Count="3" />
      <LineId Id="19" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="1" />
      <LineId Id="33" Count="3" />
      <LineId Id="32" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="47" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="43" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="49" Count="3" />
      <LineId Id="68" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.writeZeroPosToChip">
      <LineId Id="16" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="17" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.zeroPosCode">
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="45" Count="2" />
      <LineId Id="58" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="50" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="55" Count="2" />
      <LineId Id="54" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.zeroPosDecode">
      <LineId Id="40" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="65" Count="0" />
      <LineId Id="68" Count="3" />
      <LineId Id="67" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>