<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_Instrument" Id="{8c0067f5-f42b-4462-b105-279d3ba7139d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Instrument

VAR_IN_OUT CONSTANT
	i_slaveArm	:FB_SlaveArm;
END_VAR

VAR
	//IP of operating arm
	m_armNetId:T_AmsNetId; 	
	
	//Joint port number
	m_jointInstruAddr:UINT;	

	//Arm LED Prot	
	m_LEDPortAddr:UINT;		
	
	//The state and parameters readed from the instrument
	m_onChipData:ST_InstruOnChipData;
	
	// instrument kinematic parameters
	m_kinematicParameters:ST_InstruKinematicParam; 
	
	// joint position when instrument is at ZERO posture
	m_jntPosOffset:Vec8d;
	
	// reduction from motor joint to endoscope rotate joint
	m_endoscopeRotateReduction :LREAL := 2/3;
	
	// flag if endoscope is 30deg
	m_endoscope30Deg :BOOL:=true;
	
	// joint single link position when instrument at zero posture
	// TODO: move parameters below to instrument chip
	m_zeroPosNeedleGripper :Vec5d :=[-4.5, -4.5, 2.0, -0.8 , 0];
	
	// variables used to read instrument information
	m_Step:INT;
	m_Value:UDINT;
	m_ReadDelay:TON;
	m_DealyTime:TIME:=T#0.5S;
	m_IDReadResult:UDINT;
	m_IDResult:ULINT;
	m_SeriesReadResult:UDINT;
	m_PosReadResult:UDINT;
	m_PosL1,m_PosL2,m_PosL3:UDINT;
	m_signL1,m_signL2,m_signL3:UDINT;
	m_UsageReadResult:ULINT;
	m_InstruUsageToLED:ULINT;
	m_InstruSeriesRecord:ARRAY [1..100] OF ULINT;
	m_HaveRecord:BOOL;
	m_SdoWrite:FB_EcCoESdoWrite;
	m_SdoRead:FB_EcCoESdoRead;
	
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="property" Id="{9d49480e-8469-42fe-9794-09bbda49b553}" />
    <Property Name="endoscope30Deg" Id="{4bce8a98-2eb7-4bb1-9eae-0e7d18b990ab}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY endoscope30Deg : bool]]></Declaration>
      <Get Name="Get" Id="{abceb35e-0bca-4bf2-b494-bd59bc26f3c4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[endoscope30Deg := m_endoscope30Deg;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{0322fa43-406c-4982-b018-d60301dbd76c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[m_endoscope30Deg := endoscope30Deg;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="gripAngleMap" Id="{b8d7e03a-0cbe-42c6-a7e6-6b03109deb8f}">
      <Declaration><![CDATA[METHOD gripAngleMap : BOOL
VAR_INPUT
	// master gripper angle
	i_masterGripAng :LREAL;
END_VAR

VAR_OUTPUT
	// slave instrument gripper angle
	o_instruGripAngle :LREAL;
	
	// slave instrument grip force	
	o_instruGripForceLevel :LREAL;
END_VAR

VAR
	gripLevel :REAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// finger closed and force applied
IF i_masterGripAng < g_masterGripForceStartAng THEN
	o_instruGripAngle := m_kinematicParameters.m_minGripAngle;
	// NOTE: force is applied from 50%，as minimum gripper angle already apply some sort of force
	o_instruGripForceLevel := 50+50*(g_masterGripForceStartAng - i_masterGripAng)/(g_masterGripForceStartAng - g_minMasterGripAngle);
// finger open
ELSE
	o_instruGripAngle := (g_maxMasterGripAngle - i_masterGripAng)/(g_maxMasterGripAngle - g_masterGripForceStartAng);
	o_instruGripAngle :=m_kinematicParameters.m_maxGripAngle - o_instruGripAngle * (m_kinematicParameters.m_maxGripAngle - m_kinematicParameters.m_minGripAngle);
	o_instruGripForceLevel:=0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="gripperAngleForwardTransform_ID12" Id="{d3dda96d-7b55-4cf3-9ffe-c8cf53ace77d}">
      <Declaration><![CDATA[METHOD gripperAngleForwardTransform_ID12 : BOOL
VAR_INPUT
	frontAngle:LREAL;
END_VAR
VAR_OUTPUT
	endAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	minFrontAng :LREAL  := 16.6*2*g_deg2Rad;
	maxFrontAng :LREAL := 49.18*2*g_deg2Rad;
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	Angle_Initial_A:LREAL := 16.6 * g_deg2Rad; 
	SIN_C,Angle_Initial_C,End_Angle_Single,Angle_Inc_C,Angle_C,SIN_A,Angle_A,Angle_Inc_A:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//**************已知：器械前端开合角，求解：末端开合角***************//

//输入合法性判断，物理极限是[16.6*2，49.18*2]度
frontAngle := LIMIT(minFrontAng, frontAngle, maxFrontAng);


SIN_C:=AB*SIN(Angle_Initial_A)/BC;
Angle_Initial_C:=ASIN(SIN_C);

Angle_Inc_A:=frontAngle/2;
Angle_A:=Angle_Initial_A+Angle_Inc_A;

SIN_C:=AB*SIN(Angle_A)/BC;
Angle_C:=ASIN(SIN_C);

Angle_Inc_C:=Angle_C-Angle_Initial_C;
endAngle:=Angle_Inc_C*2;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="gripperAngleInverseTransform_ID12" Id="{d41bf91a-0d5c-464e-b520-ee71cb3a1637}">
      <Declaration><![CDATA[METHOD gripperAngleInverseTransform_ID12 : BOOL
VAR_INPUT
	endAngle:LREAL;
END_VAR
VAR_OUTPUT
	frontAngle:LREAL;
	Succeed:BOOL;
END_VAR
VAR
	minEndAng :LREAL  := 0;
	maxEndAng :LREAL := 38*g_deg2Rad;
	AB :LREAL := 2.8;
	BC:LREAL := 5.26;
	Angle_Initial_A:LREAL := 16.6 * g_deg2Rad; 
	
	SIN_C,Angle_Initial_C,End_Angle_Single,Angle_Inc_C,Angle_C,SIN_A,Angle_A,Angle_Inc_A:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//***************已知：器械末端开合角，求解：前端开合角********************//

//输入合法性判断，物理极限是[0,30]度
endAngle:= LIMIT(minEndAng, endAngle, maxEndAng);

SIN_C:=AB*SIN(Angle_Initial_A)/BC;
Angle_Initial_C:=ASIN(SIN_C);

End_Angle_Single:=endAngle/2;
Angle_Inc_C:=End_Angle_Single;
Angle_C:=Angle_Initial_C+Angle_Inc_C;

SIN_A:=BC*SIN(Angle_C)/AB;
Angle_A:=ASIN(SIN_A);

Angle_Inc_A:=Angle_A-Angle_Initial_A;
frontAngle:=Angle_Inc_A*2;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{b6799ae1-8e52-4442-8aea-44a9f33a3afc}">
      <Declaration><![CDATA[METHOD init : BOOL
VAR_INPUT
	armIdx :INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Update the IP and port number of the operating arm
m_armNetId:=GVL_SlaveJointEncoderCaliData.g_slaveArmNetID[armIdx];
m_jointInstruAddr:=GVL_SlaveJointEncoderCaliData.g_slaveJointNetPort[armIdx,4];]]></ST>
      </Implementation>
    </Method>
    <Method Name="initInstruJntPos" Id="{9abce61f-f34d-42ca-a401-a8190ac28e6c}">
      <Declaration><![CDATA[METHOD initInstruJntPos : BOOL
VAR_INPUT
	m_curJntPos :Vec8d;
END_VAR

VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i := 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=m_curJntPos[i];
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruFK" Id="{097c05ed-881a-44a5-815d-27300cef479f}">
      <Declaration><![CDATA[// convert motor joint position to DH joint position
METHOD PUBLIC instruFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint position of slave arm
	i_jntPos :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint positon
	r_DHJntPos :Vec6d;

	// gripper angle
	r_gripAngle :LREAL;
END_VAR

VAR
	jntPosL1,jntPosL2,jntPosL3,jntPosL4,jntPosL5 :LREAL;
	gripAngle:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntPos[1]:=i_jntPos[1];
r_DHJntPos[2]:=i_jntPos[2];
r_DHJntPos[3]:=i_jntPos[3];

// ################## endoscope ############################
IF m_onChipData.m_Instrutype = InstruType_endoscope THEN
	r_DHJntPos[4]:=-m_endoscopeRotateReduction*(i_jntPos[8]-m_jntPosOffset[8]);
	IF m_endoscope30Deg THEN
		r_DHJntPos[5]:=-pi/2+30*g_deg2Rad;
	ELSE
		r_DHJntPos[5]:=-pi/2;
	END_IF
	r_DHJntPos[6]:=0;
	RETURN;
END_IF

//#################### instrument forward kinematic ############
// convert motor joint position to instrument joint position
jntPosL1:=(i_jntPos[4]-m_jntPosOffset[4]);
jntPosL2:=(i_jntPos[5]-m_jntPosOffset[5]);
jntPosL3:=(i_jntPos[6]-m_jntPosOffset[6]);
jntPosL4:=-(i_jntPos[7]-m_jntPosOffset[7]);
jntPosL5:=-(i_jntPos[8]-m_jntPosOffset[8]);

// instrument FK in local coordinate
r_DHJntPos[4]:=jntPosL4/m_kinematicParameters.kx;
r_DHJntPos[5]:=jntPosL3/m_kinematicParameters.ky;
r_DHJntPos[6]:=(jntPosL1-jntPosL2-2*r_DHJntPos[5]*m_kinematicParameters.k13*m_kinematicParameters.kz)/(2*m_kinematicParameters.m_openAngleDir*m_kinematicParameters.kz);

// convert instrument rotation to arm DH joint position
r_DHJntPos[5]:=-r_DHJntPos[5]-pi/2;
r_DHJntPos[6]:=-r_DHJntPos[6];

// grip angle
gripAngle:=(jntPosL1+jntPosL2)/(m_kinematicParameters.m_openAngleDir*m_kinematicParameters.kz);

//################### gripper angle handle #################
IF (12=onChipData.m_InstruID) THEN//细齿无创抓钳
	gripperAngleForwardTransform_ID12(frontAngle:= gripAngle, endAngle=> r_gripAngle);

ELSIF (16 =onChipData.m_InstruID) THEN//单级电钩
	r_gripAngle:=0;
	
ELSE
	r_gripAngle:=gripAngle;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruIDRecord" Id="{f3567262-d84c-4741-97fb-36ae0b451ee9}">
      <Declaration><![CDATA[METHOD InstruIDRecord :ARRAY [1..100] OF  ULINT
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
END_VAR

VAR
	k1:INT;
	Have_Data:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		Have_Data:=TRUE;
		EXIT;
	ELSE
		Have_Data:=FALSE;
	END_IF
END_FOR

IF Have_Data=FALSE THEN
	FOR k1:= 1 TO 99 BY 1 DO
		InstruIDRecord[k1+1]:=i_ArrayData[k1];
	END_FOR
	InstruIDRecord[1]:=i_NewValue;
ELSE
	InstruIDRecord:=i_ArrayData ;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruIK" Id="{9a18f93c-de08-4a8c-a2e3-32833c619719}">
      <Declaration><![CDATA[METHOD instruIK : BOOL
VAR_INPUT
	// DH  joint positon
	i_DHJntPos :Vec6d;

	// gripper angle
	i_gripAngle :LREAL;
	
END_VAR
VAR_OUTPUT
	o_jntPos:Vec8d;
END_VAR
VAR
	gripAngle:LREAL;
	i:INT;
	rot_x:lreal;
	rot_y:lreal;
	rot_z:lreal;

	kx,ky,kz,k13,k23:LREAL;
	open_direction:INT;
	
	d,ra:LREAL;
	AngleOffsetL3:LREAL;
	m_targetOffsetL3:LREAL;
	m_actOffsetL3:LREAL;
	
	m_gripAnglePbox:Vec8d;

	L3Offset:LREAL:=-3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[o_jntPos[1] := i_DHJntPos[1];
o_jntPos[2] := i_DHJntPos[2];
o_jntPos[3] := i_DHJntPos[3];

// ################## endoscope ############################
IF m_onChipData.m_Instrutype = InstruType_endoscope THEN
	o_jntPos[8] := -i_DHJntPos[4]/m_endoscopeRotateReduction + m_jntPosOffset[8];
	o_jntPos[4]:=0;
	o_jntPos[6]:=0;
	o_jntPos[6]:=0;
	o_jntPos[7]:=0;
	RETURN;
END_IF

//################### gripper angle handle #################
IF (12=onChipData.m_InstruID) THEN//细齿无创抓钳
	gripperAngleInverseTransform_ID12(endAngle:= i_gripAngle, frontAngle=> gripAngle);
	
ELSIF 16 = onChipData.m_InstruID THEN//单级电钩\电铲
	gripAngle:=0;
	
ELSE
	gripAngle:=i_gripAngle;
END_IF

// ################# instrument inverse kinematic ##############
// convert arm DH joint position to  instrument rotation
rot_x:=i_DHJntPos[4];
rot_y:=-i_DHJntPos[5]-pi/2;
rot_z:=-i_DHJntPos[6];

// instrument IK in local coordinate
k13:=m_kinematicParameters.k13;
k23:=m_kinematicParameters.k23;
kx:=m_kinematicParameters.kx;
ky:=m_kinematicParameters.ky;
kz:=m_kinematicParameters.kz;
d:=m_kinematicParameters.m_openAngleDir;

m_gripAnglePbox[7]:=rot_x*kx;
m_gripAnglePbox[6]:=rot_y*ky;
ra:=gripAngle;
m_gripAnglePbox[4]:=rot_y*k13*kz+d*rot_z*kz+d*ra*kz/2;
m_gripAnglePbox[5]:=-rot_y*k23*kz-d*rot_z*kz+d*ra*kz/2;

// convert instrument joint position to motor joint position
o_jntPos[4] := m_gripAnglePbox[4] + m_jntPosOffset[4];
o_jntPos[5] := m_gripAnglePbox[5] + m_jntPosOffset[5];
o_jntPos[6] := m_gripAnglePbox[6] + m_jntPosOffset[6];
o_jntPos[7] := -m_gripAnglePbox[7] + m_jntPosOffset[7];
o_jntPos[8] := -m_gripAnglePbox[8] + m_jntPosOffset[8];


]]></ST>
      </Implementation>
    </Method>
    <Method Name="instruJntVelFK" Id="{a9276aa2-9909-457e-91a6-03a2e37295b6}">
      <Declaration><![CDATA[// convert motor joint velocity to DH joint velocity
METHOD PUBLIC instruJntVelFK : BOOL
VAR_IN_OUT CONSTANT
	// motor joint velocity of slave arm
	i_jntVel :Vec8d;
END_VAR

VAR_IN_OUT
	// instrument DH  joint velocity
	r_DHJntVel :Vec6d;
END_VAR

VAR
	jntPosL1,jntPosL2,jntPosL3,jntPosL4,jntPosL5 :LREAL;
	gripAngle:LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_DHJntVel[1]:=i_jntVel[1];
r_DHJntVel[2]:=i_jntVel[2];
r_DHJntVel[3]:=i_jntVel[3];

r_DHJntVel[4]:=-i_jntVel[7]/m_kinematicParameters.kx;
r_DHJntVel[5]:=i_jntVel[6]/m_kinematicParameters.ky;
r_DHJntVel[6]:=(i_jntVel[4]-i_jntVel[5]-2*r_DHJntVel[5]*m_kinematicParameters.k13*m_kinematicParameters.kz)/(2*m_kinematicParameters.m_openAngleDir*m_kinematicParameters.kz);
r_DHJntVel[5]:=-r_DHJntVel[5];
r_DHJntVel[6]:=-r_DHJntVel[6];]]></ST>
      </Implementation>
    </Method>
    <Method Name="InstruSreiesFind" Id="{f880300d-e9dd-456f-88b6-72b1cc8bd3d5}">
      <Declaration><![CDATA[METHOD InstruSreiesFind : BOOL
VAR_INPUT
	i_NewValue:ULINT;
	i_ArrayData:ARRAY [1..100] OF ULINT;
	
END_VAR

VAR
	k1:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[InstruSreiesFind:=FALSE;
FOR k1:= 1 TO 100 BY 1 DO
	IF i_NewValue=i_ArrayData[k1] THEN
		InstruSreiesFind:=TRUE;
		EXIT;
	ELSE
		InstruSreiesFind:=FALSE;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Property Name="kinematicParameters" Id="{e7ad17bd-82e9-477e-9e66-6a8feac51534}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY kinematicParameters :REFERENCE TO ST_InstruKinematicParam]]></Declaration>
      <Get Name="Get" Id="{d0447347-931d-4e2e-81b2-c8e4acc99fd6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[kinematicParameters ref=m_kinematicParameters;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="onChipData" Id="{093a4217-bb32-41a8-a667-4570e97851b1}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY onChipData : REFERENCE TO ST_InstruOnChipData]]></Declaration>
      <Get Name="Get" Id="{f9328823-d656-4b2e-b51e-d2d3d6c6297d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[onChipData ref=m_onChipData;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="readParameters" Id="{fafb5a79-7caf-47d4-9d2f-b3dbd95048cf}">
      <Declaration><![CDATA[METHOD readParameters : BOOL
VAR_INPUT
	startFlag :BOOL;
END_VAR

VAR
	paramIdx :INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: read m_kinematic parameters from chip 
//Take the rising edge of the read signal
m_ReadDelay(IN:= m_Step=10, PT:= m_DealyTime, Q=> , ET=> );//计时器
IF startFlag THEN
	m_Step:=0;
	m_onChipData.m_InstruReadSucceed:=FALSE;
	m_onChipData.m_Error:=FALSE;
	m_onChipData.m_ErrorID:=0;
END_IF


CASE m_Step OF
	
	0://向6093发送0x8000  0000---发送读取信号
		m_Value:=16#80000000; 
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr, nSubIndex:= 0, nIndex:= 16#6093, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=10;
		END_IF
		
		
	10://延时0.5s、防止值还没有返回
		IF m_ReadDelay.Q THEN
			m_Step:=20;
		END_IF

		
	20://从6093地址中拿值
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6093, pDstBuf:= ADR(m_IDReadResult), cbBufLen:= SIZEOF(m_IDReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=30;
		END_IF	
		
	
	30://处理器械ID、低16位
		m_IDResult:=UDINT_TO_ULINT(16#0000FFFF AND m_IDReadResult);
		m_Step:=40;
		
		
	40://读取6095、器械序列号
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6095, pDstBuf:= ADR(m_SeriesReadResult), cbBufLen:= SIZEOF(m_SeriesReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=50;
		END_IF	
	
		
	50://处理序列号，低30位
		m_onChipData.m_InstruseriesNum:=SHL(m_IDResult,31)+(16#7FFFFFFF AND m_SeriesReadResult);
		m_onChipData.m_InstruID:=LREAL_TO_INT(FLOOR(lr_in:= m_onChipData.m_InstruseriesNum/EXPT(10,9))); //取十进制前三位为器械ID
		m_Step:=60;
		
		
	60://读取6096---器械零点位置
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6096, pDstBuf:= ADR(m_PosReadResult), cbBufLen:= SIZEOF(m_PosReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=70;
		END_IF	
		
		
	70: //处理位置，L1:0-9位，L2:10-19位，L3:20-29位
		m_PosL1:=16#000001FF AND m_PosReadResult;  //0000  01FF                             01,1111,1111
		m_PosL2:=SHR((16#0007FC00 AND m_PosReadResult),10);  //0007  F600        0111,1111,1100,0000,0000
		m_PosL3:=SHR((16#1FF00000 AND m_PosReadResult),20); //        01,1111,1111,0000,0000,0000,0000,0000
		m_signL1:=16#0200 AND m_PosReadResult;
		m_signL2:=SHR((16#80000 AND m_PosReadResult),10);
		m_signL3:=SHR((16#20000000 AND m_PosReadResult),20);
		
		IF m_signL1=512 THEN
			m_onChipData.m_InstruPos[1]:=-UDINT_TO_LREAL(m_PosL1)/50;
		ELSE
			m_onChipData.m_InstruPos[1]:=UDINT_TO_LREAL(m_PosL1)/50;
		END_IF
		
		IF m_signL2=512 THEN
			m_onChipData.m_InstruPos[2]:=-UDINT_TO_LREAL(m_PosL2)/50;
		ELSE
			m_onChipData.m_InstruPos[2]:=UDINT_TO_LREAL(m_PosL2)/50;
		END_IF
		
		IF m_signL3=512 THEN
			m_onChipData.m_InstruPos[3]:=-UDINT_TO_LREAL(m_PosL3)/50;
		ELSE
			m_onChipData.m_InstruPos[3]:=UDINT_TO_LREAL(m_PosL3)/50;
		END_IF
		
		m_Step:=80;
	
		
		
	80://读取器械使用次数 6094
		m_SdoRead(sNetId:= m_ArmNetId, nSlaveAddr:= m_JointInstruAddr,	nSubIndex:= 0, nIndex:= 16#6094, pDstBuf:= ADR(m_UsageReadResult), cbBufLen:= SIZEOF(m_UsageReadResult), bExecute:= TRUE, 	tTimeout:= , bBusy=> , bError=> , nErrId=> , cbRead=> );
		IF NOT m_SdoRead.bBusy THEN
			m_SdoRead(bExecute:=FALSE);
			m_Step:=90;
		END_IF	
		
		
	90://处理器械使用次数读取结果
		m_onChipData.m_InstruusageCounts:=m_UsageReadResult;
		m_InstruUsageToLED:=LIMIT(0,m_UsageReadResult,99);
		m_Step:=110;
		
		
	100://将器械使用次数写入LED
		m_Value:=ULINT_TO_UDINT(16#FFFF AND m_InstruUsageToLED) ;
		m_SdoWrite(sNetId:= m_ArmNetId, nSlaveAddr:= m_LEDPortAddr, nSubIndex:= 06, nIndex:= 16#6090, pSrcBuf:= ADR(m_Value), cbBufLen:= SIZEOF(m_Value), bExecute:= TRUE, tTimeout:= , bBusy=> , bError=> , nErrId=> );
		IF NOT m_SdoWrite.bBusy THEN
			m_SdoWrite(bExecute:=FALSE);
			m_Step:=110;
		END_IF
		
	110://处理当器械使用次数达到上限后、在同一场手术中还能使用
		IF m_onChipData.m_InstruusageCounts=m_onChipData.m_InstrumaxUsageCounts THEN
			m_InstruSeriesRecord:=InstruIDRecord(i_NewValue:= m_onChipData.m_InstruusageCounts, i_ArrayData:= m_InstruSeriesRecord);
			m_Step:=120;
		ELSE
			m_Step:=120;
		END_IF
		
		
		
	120://结果诊断
	// TODO : endoscope can not be readed
		IF m_onChipData.m_InstruID<1 THEN
			m_onChipData.m_Error:=TRUE;
			m_onChipData.m_ErrorID:=1;
(*		ELSIF m_onChipData.m_InstruusageCounts>m_onChipData.m_InstrumaxUsageCounts AND m_onChipData.m_InstruID<>20 THEN
			m_HaveRecord:=InstruSreiesFind(i_NewValue:=m_onChipData.m_InstruseriesNum , i_ArrayData:=m_InstruSeriesRecord );
			IF m_HaveRecord THEN
				m_onChipData.m_Instrutype:=2;
				m_onChipData.m_InstruReadSucceed:=TRUE;
				m_Step:=130;
			ELSE
				m_onChipData.m_Error:=TRUE;
				m_onChipData.m_ErrorID:=2;
			END_IF*)
		ELSE
			IF m_onChipData.m_InstruID = 20 OR m_onChipData.m_InstruID = 9665 THEN
				m_onChipData.m_Instrutype :=  InstruType_endoscope;
			ELSE
				m_onChipData.m_Instrutype :=  InstruType_NeedleGripper;
			END_IF
			m_onChipData.m_InstruReadSucceed:=TRUE;
			m_Step:=130;
		END_IF
	
	130://控制参数赋值、现在先用原有的  后续改为从芯片中读取
		paramIdx :=LIMIT(1, m_onChipData.m_InstruID, 30);
		m_kinematicParameters.k13:=k13[paramIdx];
		m_kinematicParameters.k23:=k23[paramIdx];
		m_kinematicParameters.kx:=kx[paramIdx];
		m_kinematicParameters.ky:=ky[paramIdx];
		m_kinematicParameters.kz:=kz[paramIdx];
		m_Step:=-1;
	
END_CASE

//NOTE: zero posture data is defined as single link position, need to update to chip later
IF m_onChipData.m_Instrutype = InstruType_NeedleGripper THEN
	m_onChipData.m_InstruPos := m_zeroPosNeedleGripper;
END_IF

// update instrument kinematic parameters based on readed info
IF InstruType_NeedleGripper =  m_onChipData.m_Instrutype THEN
	m_kinematicParameters.m_fingerLength := 0.01;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{90292eaa-1cc4-4b19-b4f6-6bcd7c03eb33}">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_onChipData.m_InstruID := 0;
m_onChipData.m_InstruseriesNum :=0;
m_onChipData.m_Instrutype :=InstruType_UNKNOWM;
m_onChipData.m_Error:=FALSE;
m_onChipData.m_ErrorID:=0;
m_onChipData.m_InstruReadSucceed:=FALSE;

FOR i:= 4 TO 8 BY 1 DO
	m_jntPosOffset[i]:=0;
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Instrument">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.endoscope30Deg.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.endoscope30Deg.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.gripAngleMap">
      <LineId Id="22" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="26" Count="3" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.gripperAngleForwardTransform_ID12">
      <LineId Id="6" Count="3" />
      <LineId Id="44" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="20" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.gripperAngleInverseTransform_ID12">
      <LineId Id="12" Count="3" />
      <LineId Id="54" Count="0" />
      <LineId Id="24" Count="13" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.init">
      <LineId Id="7" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.initInstruJntPos">
      <LineId Id="9" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="11" Count="1" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruFK">
      <LineId Id="131" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="189" Count="0" />
      <LineId Id="188" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="193" Count="0" />
      <LineId Id="196" Count="1" />
      <LineId Id="199" Count="1" />
      <LineId Id="198" Count="0" />
      <LineId Id="191" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="192" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="132" Count="1" />
      <LineId Id="126" Count="4" />
      <LineId Id="160" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="181" Count="2" />
      <LineId Id="136" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="91" Count="8" />
      <LineId Id="158" Count="1" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruIDRecord">
      <LineId Id="12" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruIK">
      <LineId Id="528" Count="1" />
      <LineId Id="527" Count="0" />
      <LineId Id="532" Count="2" />
      <LineId Id="543" Count="0" />
      <LineId Id="541" Count="0" />
      <LineId Id="544" Count="2" />
      <LineId Id="542" Count="0" />
      <LineId Id="531" Count="0" />
      <LineId Id="547" Count="0" />
      <LineId Id="530" Count="0" />
      <LineId Id="549" Count="9" />
      <LineId Id="548" Count="0" />
      <LineId Id="480" Count="0" />
      <LineId Id="395" Count="2" />
      <LineId Id="481" Count="0" />
      <LineId Id="390" Count="0" />
      <LineId Id="389" Count="0" />
      <LineId Id="391" Count="0" />
      <LineId Id="388" Count="0" />
      <LineId Id="392" Count="2" />
      <LineId Id="7" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="385" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="56" Count="0" />
      <LineId Id="483" Count="0" />
      <LineId Id="492" Count="4" />
      <LineId Id="324" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.instruJntVelFK">
      <LineId Id="131" Count="0" />
      <LineId Id="134" Count="1" />
      <LineId Id="200" Count="3" />
      <LineId Id="159" Count="0" />
      <LineId Id="220" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.InstruSreiesFind">
      <LineId Id="34" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.kinematicParameters.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.onChipData.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.readParameters">
      <LineId Id="5" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="219" Count="0" />
      <LineId Id="222" Count="2" />
      <LineId Id="220" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="45" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="29" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="61" Count="2" />
      <LineId Id="58" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="64" Count="2" />
      <LineId Id="70" Count="1" />
      <LineId Id="74" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="76" Count="3" />
      <LineId Id="75" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="80" Count="1" />
      <LineId Id="83" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="90" Count="1" />
      <LineId Id="93" Count="3" />
      <LineId Id="92" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="107" Count="22" />
      <LineId Id="360" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="141" Count="1" />
      <LineId Id="56" Count="0" />
      <LineId Id="137" Count="3" />
      <LineId Id="136" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="150" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="148" Count="1" />
      <LineId Id="132" Count="0" />
      <LineId Id="155" Count="4" />
      <LineId Id="154" Count="0" />
      <LineId Id="151" Count="1" />
      <LineId Id="162" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="164" Count="2" />
      <LineId Id="161" Count="0" />
      <LineId Id="273" Count="1" />
      <LineId Id="153" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="387" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="176" Count="1" />
      <LineId Id="180" Count="1" />
      <LineId Id="249" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="184" Count="2" />
      <LineId Id="183" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="371" Count="1" />
      <LineId Id="374" Count="1" />
      <LineId Id="373" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="282" Count="0" />
      <LineId Id="175" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="275" Count="0" />
      <LineId Id="379" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="283" Count="3" />
      <LineId Id="308" Count="0" />
      <LineId Id="276" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="362" Count="3" />
      <LineId Id="331" Count="0" />
      <LineId Id="366" Count="0" />
      <LineId Id="330" Count="0" />
      <LineId Id="333" Count="1" />
      <LineId Id="332" Count="0" />
      <LineId Id="196" Count="0" />
    </LineIds>
    <LineIds Name="FB_Instrument.reset">
      <LineId Id="5" Count="2" />
      <LineId Id="11" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>